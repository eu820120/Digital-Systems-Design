KCPSM3  v1.30.      Ken Chapman (Xilinx-UK) 2005

The assembler for KCPSM3 Programmable State Machine

PASS 1 - Reading input PSM file

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_port, 80               ;8 simple LEDs. Is an OUTPUT port.
CONSTANT DATA_IN_PORT, 00         ;input data port. this is an INPUT port.
CONSTANT LED_ADDR_port, 40
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00        ;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01        ;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02        ;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03        ;Preserve s3 contents during ISR
;
CONSTANT SUM, 04            ;SUM store
CONSTANT SUM2, 05           ;SUM store
CONSTANT COUNT, 06          ;counter store
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F       ;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D           ;carriage return
CONSTANT character_question, 3F     ;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21      ;'!'
CONSTANT character_BS, 08           ;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start: LOAD s0, 00
STORE s0, SUM
STORE s0, SUM2
STORE s0, COUNT
OUTPUT s0, LED_port
;
ENABLE INTERRUPT                    ;enable interrupts
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program: CALL delay_1s
LOAD s0, 01
OUTPUT s0, LED_port
CALL delay_1s
LOAD s0, 00
OUTPUT s0, LED_port
JUMP main_program
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28                         ;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19                         ;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14                         ;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
delay_100ms: LOAD s3, 64                         ;100 x 1ms = 20ms
wait_100ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_100ms
RETURN
delay_200ms: LOAD s3, C8                         ;200 x 1ms = 20ms
wait_200ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_200ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32                         ;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;
ISR: STORE s0, ISR_preserve_s0           ;preserve register
STORE s1, ISR_preserve_s1           ;preserve register
STORE s2, ISR_preserve_s2           ;preserve register
STORE s3, ISR_preserve_s3           ;preserve register
AND s0, s0                          ;clear carry
XOR s0, s0                          ;clear register, clear zero flag
AND s1, s1                          ;clear carry
XOR s1, s1                          ;clear register, clear zero flag
AND s2, s2                          ;clear carry
XOR s2, s2                          ;clear register, clear zero flag
AND s3, s3                          ;clear carry
XOR s3, s3                          ;clear register, clear zero flag
INPUT s0, DATA_IN_PORT              ;get new audio_data
FETCH s1, SUM                       ;get SUM
FETCH s2, SUM2                      ;get SUM2 (higher 8 bits)
FETCH s3, COUNT                     ;get counter (0 to 256)
COMPARE s0, 80                      ;check if audio_data[7] is 1
JUMP Z, twos_comp
JUMP NC, twos_comp
JUMP addition
twos_comp: XOR s0, FF                          ;invert
ADD s0, 01                          ;Add 1
addition: ADD s1, s0
ADDCY s2, 00
count256: COMPARE s3, FF
JUMP Z, display_leds
ADD s3, 01
JUMP returnn
display_leds:  SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1                                ;left shift 8 times (divide by 256)
msb8:   COMPARE s1, 80                        ;check if s1[7] is one or not
JUMP C, msb7
LOAD s1, FF
JUMP displayy
msb7:   COMPARE s1, 40                        ;check if s1[6] is one or not
JUMP C, msb6
LOAD s1, FE
JUMP displayy
msb6:   COMPARE s1, 20                        ;check if s1[5] is one or not
JUMP C, msb5
LOAD s1, FC
JUMP displayy
msb5:   COMPARE s1, 10                        ;check if s1[4] is one or not
JUMP C, msb4
LOAD s1, F8
JUMP displayy
msb4:   COMPARE s1, 08                        ;check if s1[3] is one or not
JUMP C, msb3
LOAD s1, F0
JUMP displayy
msb3:   COMPARE s1, 04                        ;check if s1[2] is one or not
JUMP C, msb2
LOAD s1, E0
JUMP displayy
msb2:   COMPARE s1, 02                        ;check if s1[1] is one or not
JUMP C, msb1
LOAD s1, C0
JUMP displayy
msb1:   COMPARE s1, 01                        ;check if s1[0] is one or not
JUMP C, msb0
LOAD s1, 80
JUMP displayy
msb0:   LOAD s1, 00
displayy:   OUTPUT s1, LED_ADDR_port              ;display counter value on LEDs
LOAD s1, 00
LOAD s2, 00
LOAD s3, 00                            ;counter goes to zero
returnn:  STORE s1, SUM                         ;store sum
STORE s2, SUM2                        ;store sum higher bits
STORE s3, COUNT                       ;store counter
FETCH s0, ISR_preserve_s0           ;restore register
FETCH s1, ISR_preserve_s1           ;restore register
FETCH s2, ISR_preserve_s2           ;restore register
FETCH s3, ISR_preserve_s3           ;restore register
RETURNI ENABLE
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 2 - Testing Instructions

; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
;
;
;
;
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
; one second intervals.
;
;
;**************************************************************************************
; Port definitions
;**************************************************************************************
;
;
;
CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
CONSTANT DATA_IN_PORT, 00;input data port. this is an INPUT port.
CONSTANT LED_ADDR_port, 40
;**************************************************************************************
; Special Register usage
;**************************************************************************************
;
; No registers are given special names in this program.
;
;**************************************************************************************
; Scratch Pad Memory Locations
;**************************************************************************************
;
;
CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
;
CONSTANT SUM, 04;SUM store
CONSTANT SUM2, 05;SUM store
CONSTANT COUNT, 06;counter store
;
;**************************************************************************************
; Useful data constants
;**************************************************************************************
;
;
; Constant to define a software delay of 1us. This must be adjusted to reflect the
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
; calculation highly predictable. The '6' in the following equation even allows for
; 'CALL delay_1us' instruction in the initiating code.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
; For clock rates below 10MHz the value of 1 must be used and the operation will
; become lower than intended. Interrupts may effect the timing of software based
; delays.
;
CONSTANT delay_1us_constant, 0B
;
;
;
; ASCII table
;
CONSTANT character_a, 61
CONSTANT character_b, 62
CONSTANT character_c, 63
CONSTANT character_d, 64
CONSTANT character_e, 65
CONSTANT character_f, 66
CONSTANT character_g, 67
CONSTANT character_h, 68
CONSTANT character_i, 69
CONSTANT character_j, 6A
CONSTANT character_k, 6B
CONSTANT character_l, 6C
CONSTANT character_m, 6D
CONSTANT character_n, 6E
CONSTANT character_o, 6F
CONSTANT character_p, 70
CONSTANT character_q, 71
CONSTANT character_r, 72
CONSTANT character_s, 73
CONSTANT character_t, 74
CONSTANT character_u, 75
CONSTANT character_v, 76
CONSTANT character_w, 77
CONSTANT character_x, 78
CONSTANT character_y, 79
CONSTANT character_z, 7A
CONSTANT character_A, 41
CONSTANT character_B, 42
CONSTANT character_C, 43
CONSTANT character_D, 44
CONSTANT character_E, 45
CONSTANT character_F, 46
CONSTANT character_G, 47
CONSTANT character_H, 48
CONSTANT character_I, 49
CONSTANT character_J, 4A
CONSTANT character_K, 4B
CONSTANT character_L, 4C
CONSTANT character_M, 4D
CONSTANT character_N, 4E
CONSTANT character_O, 4F
CONSTANT character_P, 50
CONSTANT character_Q, 51
CONSTANT character_R, 52
CONSTANT character_S, 53
CONSTANT character_T, 54
CONSTANT character_U, 55
CONSTANT character_V, 56
CONSTANT character_W, 57
CONSTANT character_X, 58
CONSTANT character_Y, 59
CONSTANT character_Z, 5A
CONSTANT character_0, 30
CONSTANT character_1, 31
CONSTANT character_2, 32
CONSTANT character_3, 33
CONSTANT character_4, 34
CONSTANT character_5, 35
CONSTANT character_6, 36
CONSTANT character_7, 37
CONSTANT character_8, 38
CONSTANT character_9, 39
CONSTANT character_colon, 3A
CONSTANT character_stop, 2E
CONSTANT character_semi_colon, 3B
CONSTANT character_minus, 2D
CONSTANT character_divide, 2F;'/'
CONSTANT character_plus, 2B
CONSTANT character_comma, 2C
CONSTANT character_less_than, 3C
CONSTANT character_greater_than, 3E
CONSTANT character_equals, 3D
CONSTANT character_space, 20
CONSTANT character_CR, 0D;carriage return
CONSTANT character_question, 3F;'?'
CONSTANT character_dollar, 24
CONSTANT character_exclaim, 21;'!'
CONSTANT character_BS, 08;Back Space command character
;
;
;
;
;
;**************************************************************************************
; Initialise the system
;**************************************************************************************
;
cold_start: LOAD s0, 00
STORE s0, SUM
STORE s0, SUM2
STORE s0, COUNT
OUTPUT s0, LED_port
;
ENABLE INTERRUPT;enable interrupts
;**************************************************************************************
; Main program
;**************************************************************************************
;
; Display welcome message for design
;
main_program: CALL delay_1s
LOAD s0, 01
OUTPUT s0, LED_port
CALL delay_1s
LOAD s0, 00
OUTPUT s0, LED_port
JUMP main_program
;**************************************************************************************
; Software delay routines
;**************************************************************************************
;
; Delay of 1us.
;
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
; instruction executes in 2 clock cycles making the calculation highly predictable.
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
; in the initiating code. Interrupts may effect software derived delays.
;
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
;
; Registers used s0
;
delay_1us: LOAD s0, delay_1us_constant
wait_1us: SUB s0, 01
JUMP NZ, wait_1us
RETURN
;
; Delay of 40us.
;
; Registers used s0, s1
;
delay_40us: LOAD s1, 28;40 x 1us = 40us
wait_40us: CALL delay_1us
SUB s1, 01
JUMP NZ, wait_40us
RETURN
;
;
; Delay of 1ms.
;
; Registers used s0, s1, s2
;
delay_1ms: LOAD s2, 19;25 x 40us = 1ms
wait_1ms: CALL delay_40us
SUB s2, 01
JUMP NZ, wait_1ms
RETURN
;
; Delay of 20ms.
;
; Delay of 20ms used during initialisation.
;
; Registers used s0, s1, s2, s3
;
delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
wait_20ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_20ms
RETURN
delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
wait_100ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_100ms
RETURN
delay_200ms: LOAD s3, C8;200 x 1ms = 20ms
wait_200ms: CALL delay_1ms
SUB s3, 01
JUMP NZ, wait_200ms
RETURN
;
; Delay of approximately 1 second.
;
; Registers used s0, s1, s2, s3, s4
;
delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
wait_1s: CALL delay_20ms
SUB s4, 01
JUMP NZ, wait_1s
RETURN
;
;
;
;**************************************************************************************
; Interrupt Service Routine (ISR)
;**************************************************************************************
;
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
; on the 8 LEDs.
;
ISR: STORE s0, ISR_preserve_s0;preserve register
STORE s1, ISR_preserve_s1;preserve register
STORE s2, ISR_preserve_s2;preserve register
STORE s3, ISR_preserve_s3;preserve register
AND s0, s0;clear carry
XOR s0, s0;clear register, clear zero flag
AND s1, s1;clear carry
XOR s1, s1;clear register, clear zero flag
AND s2, s2;clear carry
XOR s2, s2;clear register, clear zero flag
AND s3, s3;clear carry
XOR s3, s3;clear register, clear zero flag
INPUT s0, DATA_IN_PORT;get new audio_data
FETCH s1, SUM;get SUM
FETCH s2, SUM2;get SUM2 (higher 8 bits)
FETCH s3, COUNT;get counter (0 to 256)
COMPARE s0, 80;check if audio_data[7] is 1
JUMP Z, twos_comp
JUMP NC, twos_comp
JUMP addition
twos_comp: XOR s0, FF;invert
ADD s0, 01;Add 1
addition: ADD s1, s0
ADDCY s2, 00
count256: COMPARE s3, FF
JUMP Z, display_leds
ADD s3, 01
JUMP returnn
display_leds: SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1
SL0 s2
SLA s1;left shift 8 times (divide by 256)
msb8: COMPARE s1, 80;check if s1[7] is one or not
JUMP C, msb7
LOAD s1, FF
JUMP displayy
msb7: COMPARE s1, 40;check if s1[6] is one or not
JUMP C, msb6
LOAD s1, FE
JUMP displayy
msb6: COMPARE s1, 20;check if s1[5] is one or not
JUMP C, msb5
LOAD s1, FC
JUMP displayy
msb5: COMPARE s1, 10;check if s1[4] is one or not
JUMP C, msb4
LOAD s1, F8
JUMP displayy
msb4: COMPARE s1, 08;check if s1[3] is one or not
JUMP C, msb3
LOAD s1, F0
JUMP displayy
msb3: COMPARE s1, 04;check if s1[2] is one or not
JUMP C, msb2
LOAD s1, E0
JUMP displayy
msb2: COMPARE s1, 02;check if s1[1] is one or not
JUMP C, msb1
LOAD s1, C0
JUMP displayy
msb1: COMPARE s1, 01;check if s1[0] is one or not
JUMP C, msb0
LOAD s1, 80
JUMP displayy
msb0: LOAD s1, 00
displayy: OUTPUT s1, LED_ADDR_port;display counter value on LEDs
LOAD s1, 00
LOAD s2, 00
LOAD s3, 00;counter goes to zero
returnn: STORE s1, SUM;store sum
STORE s2, SUM2;store sum higher bits
STORE s3, COUNT;store counter
FETCH s0, ISR_preserve_s0;restore register
FETCH s1, ISR_preserve_s1;restore register
FETCH s2, ISR_preserve_s2;restore register
FETCH s3, ISR_preserve_s3;restore register
RETURNI ENABLE
;
;
;**************************************************************************************
; Interrupt Vector
;**************************************************************************************
;
ADDRESS 3FF
JUMP ISR
;
;

PASS 3 - Resolving addresses and line labels

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT DATA_IN_PORT, 00;input data port. this is an INPUT port.
000 CONSTANT LED_ADDR_port, 40
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 ;
000 CONSTANT SUM, 04;SUM store
000 CONSTANT SUM2, 05;SUM store
000 CONSTANT COUNT, 06;counter store
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: LOAD s0, 00
001 STORE s0, SUM
002 STORE s0, SUM2
003 STORE s0, COUNT
004 OUTPUT s0, LED_port
005 ;
005 ENABLE INTERRUPT;enable interrupts
006 
;**************************************************************************************
006 ; Main program
006 
;**************************************************************************************
006 ;
006 ; Display welcome message for design
006 ;
006 main_program: CALL delay_1s
007 LOAD s0, 01
008 OUTPUT s0, LED_port
009 CALL delay_1s
00A LOAD s0, 00
00B OUTPUT s0, LED_port
00C JUMP main_program
00D 
;**************************************************************************************
00D ; Software delay routines
00D 
;**************************************************************************************
00D ;
00D ; Delay of 1us.
00D ;
00D 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
00D 
; instruction executes in 2 clock cycles making the calculation highly predictable.
00D 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
00D ; in the initiating code. Interrupts may effect software derived delays.
00D ;
00D 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
00D ;
00D ; Registers used s0
00D ;
00D delay_1us: LOAD s0, delay_1us_constant
00E wait_1us: SUB s0, 01
00F JUMP NZ, wait_1us
010 RETURN
011 ;
011 ; Delay of 40us.
011 ;
011 ; Registers used s0, s1
011 ;
011 delay_40us: LOAD s1, 28;40 x 1us = 40us
012 wait_40us: CALL delay_1us
013 SUB s1, 01
014 JUMP NZ, wait_40us
015 RETURN
016 ;
016 ;
016 ; Delay of 1ms.
016 ;
016 ; Registers used s0, s1, s2
016 ;
016 delay_1ms: LOAD s2, 19;25 x 40us = 1ms
017 wait_1ms: CALL delay_40us
018 SUB s2, 01
019 JUMP NZ, wait_1ms
01A RETURN
01B ;
01B ; Delay of 20ms.
01B ;
01B ; Delay of 20ms used during initialisation.
01B ;
01B ; Registers used s0, s1, s2, s3
01B ;
01B delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
01C wait_20ms: CALL delay_1ms
01D SUB s3, 01
01E JUMP NZ, wait_20ms
01F RETURN
020 delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
021 wait_100ms: CALL delay_1ms
022 SUB s3, 01
023 JUMP NZ, wait_100ms
024 RETURN
025 delay_200ms: LOAD s3, C8;200 x 1ms = 20ms
026 wait_200ms: CALL delay_1ms
027 SUB s3, 01
028 JUMP NZ, wait_200ms
029 RETURN
02A ;
02A ; Delay of approximately 1 second.
02A ;
02A ; Registers used s0, s1, s2, s3, s4
02A ;
02A delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
02B wait_1s: CALL delay_20ms
02C SUB s4, 01
02D JUMP NZ, wait_1s
02E RETURN
02F ;
02F ;
02F ;
02F 
;**************************************************************************************
02F ; Interrupt Service Routine (ISR)
02F 
;**************************************************************************************
02F ;
02F 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
02F ; on the 8 LEDs.
02F ;
02F ISR: STORE s0, ISR_preserve_s0;preserve register
030 STORE s1, ISR_preserve_s1;preserve register
031 STORE s2, ISR_preserve_s2;preserve register
032 STORE s3, ISR_preserve_s3;preserve register
033 AND s0, s0;clear carry
034 XOR s0, s0;clear register, clear zero flag
035 AND s1, s1;clear carry
036 XOR s1, s1;clear register, clear zero flag
037 AND s2, s2;clear carry
038 XOR s2, s2;clear register, clear zero flag
039 AND s3, s3;clear carry
03A XOR s3, s3;clear register, clear zero flag
03B INPUT s0, DATA_IN_PORT;get new audio_data
03C FETCH s1, SUM;get SUM
03D FETCH s2, SUM2;get SUM2 (higher 8 bits)
03E FETCH s3, COUNT;get counter (0 to 256)
03F COMPARE s0, 80;check if audio_data[7] is 1
040 JUMP Z, twos_comp
041 JUMP NC, twos_comp
042 JUMP addition
043 twos_comp: XOR s0, FF;invert
044 ADD s0, 01;Add 1
045 addition: ADD s1, s0
046 ADDCY s2, 00
047 count256: COMPARE s3, FF
048 JUMP Z, display_leds
049 ADD s3, 01
04A JUMP returnn
04B display_leds: SL0 s2
04C SLA s1
04D SL0 s2
04E SLA s1
04F SL0 s2
050 SLA s1
051 SL0 s2
052 SLA s1
053 SL0 s2
054 SLA s1
055 SL0 s2
056 SLA s1
057 SL0 s2
058 SLA s1
059 SL0 s2
05A SLA s1;left shift 8 times (divide by 256)
05B msb8: COMPARE s1, 80;check if s1[7] is one or not
05C JUMP C, msb7
05D LOAD s1, FF
05E JUMP displayy
05F msb7: COMPARE s1, 40;check if s1[6] is one or not
060 JUMP C, msb6
061 LOAD s1, FE
062 JUMP displayy
063 msb6: COMPARE s1, 20;check if s1[5] is one or not
064 JUMP C, msb5
065 LOAD s1, FC
066 JUMP displayy
067 msb5: COMPARE s1, 10;check if s1[4] is one or not
068 JUMP C, msb4
069 LOAD s1, F8
06A JUMP displayy
06B msb4: COMPARE s1, 08;check if s1[3] is one or not
06C JUMP C, msb3
06D LOAD s1, F0
06E JUMP displayy
06F msb3: COMPARE s1, 04;check if s1[2] is one or not
070 JUMP C, msb2
071 LOAD s1, E0
072 JUMP displayy
073 msb2: COMPARE s1, 02;check if s1[1] is one or not
074 JUMP C, msb1
075 LOAD s1, C0
076 JUMP displayy
077 msb1: COMPARE s1, 01;check if s1[0] is one or not
078 JUMP C, msb0
079 LOAD s1, 80
07A JUMP displayy
07B msb0: LOAD s1, 00
07C displayy: OUTPUT s1, LED_ADDR_port;display counter value on LEDs
07D LOAD s1, 00
07E LOAD s2, 00
07F LOAD s3, 00;counter goes to zero
080 returnn: STORE s1, SUM;store sum
081 STORE s2, SUM2;store sum higher bits
082 STORE s3, COUNT;store counter
083 FETCH s0, ISR_preserve_s0;restore register
084 FETCH s1, ISR_preserve_s1;restore register
085 FETCH s2, ISR_preserve_s2;restore register
086 FETCH s3, ISR_preserve_s3;restore register
087 RETURNI ENABLE
088 ;
088 ;
088 
;**************************************************************************************
088 ; Interrupt Vector
088 
;**************************************************************************************
088 ;
088 ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 4 - Resolving Operands

000 ; KCPSM3 Program - Practice Picoblaze on Spartan-3A Starter Kit.
000 ;
000 ;
000 ;
000 ;
000 
; The 8 LEDs provide a simple 'heart beat' counter driven by interrupts generated at
000 ; one second intervals.
000 ;
000 ;
000 
;**************************************************************************************
000 ; Port definitions
000 
;**************************************************************************************
000 ;
000 ;
000 ;
000 CONSTANT LED_port, 80;8 simple LEDs. Is an OUTPUT port.
000 CONSTANT DATA_IN_PORT, 00;input data port. this is an INPUT port.
000 CONSTANT LED_ADDR_port, 40
000 
;**************************************************************************************
000 ; Special Register usage
000 
;**************************************************************************************
000 ;
000 ; No registers are given special names in this program.
000 ;
000 
;**************************************************************************************
000 ; Scratch Pad Memory Locations
000 
;**************************************************************************************
000 ;
000 ;
000 CONSTANT ISR_preserve_s0, 00;Preserve s0 contents during ISR
000 CONSTANT ISR_preserve_s1, 01;Preserve s1 contents during ISR
000 CONSTANT ISR_preserve_s2, 02;Preserve s2 contents during ISR
000 CONSTANT ISR_preserve_s3, 03;Preserve s3 contents during ISR
000 ;
000 CONSTANT SUM, 04;SUM store
000 CONSTANT SUM2, 05;SUM store
000 CONSTANT COUNT, 06;counter store
000 ;
000 
;**************************************************************************************
000 ; Useful data constants
000 
;**************************************************************************************
000 ;
000 ;
000 
; Constant to define a software delay of 1us. This must be adjusted to reflect the
000 
; clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
000 
; calculation highly predictable. The '6' in the following equation even allows for
000 ; 'CALL delay_1us' instruction in the initiating code.
000 ;
000 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
000 ;
000 ; Example: For a 50MHz clock the constant value is (50-6)/4 = 11  (0B Hex).
000 
; For clock rates below 10MHz the value of 1 must be used and the operation will
000 
; become lower than intended. Interrupts may effect the timing of software based
000 ; delays.
000 ;
000 CONSTANT delay_1us_constant, 0B
000 ;
000 ;
000 ;
000 ; ASCII table
000 ;
000 CONSTANT character_a, 61
000 CONSTANT character_b, 62
000 CONSTANT character_c, 63
000 CONSTANT character_d, 64
000 CONSTANT character_e, 65
000 CONSTANT character_f, 66
000 CONSTANT character_g, 67
000 CONSTANT character_h, 68
000 CONSTANT character_i, 69
000 CONSTANT character_j, 6A
000 CONSTANT character_k, 6B
000 CONSTANT character_l, 6C
000 CONSTANT character_m, 6D
000 CONSTANT character_n, 6E
000 CONSTANT character_o, 6F
000 CONSTANT character_p, 70
000 CONSTANT character_q, 71
000 CONSTANT character_r, 72
000 CONSTANT character_s, 73
000 CONSTANT character_t, 74
000 CONSTANT character_u, 75
000 CONSTANT character_v, 76
000 CONSTANT character_w, 77
000 CONSTANT character_x, 78
000 CONSTANT character_y, 79
000 CONSTANT character_z, 7A
000 CONSTANT character_A, 41
000 CONSTANT character_B, 42
000 CONSTANT character_C, 43
000 CONSTANT character_D, 44
000 CONSTANT character_E, 45
000 CONSTANT character_F, 46
000 CONSTANT character_G, 47
000 CONSTANT character_H, 48
000 CONSTANT character_I, 49
000 CONSTANT character_J, 4A
000 CONSTANT character_K, 4B
000 CONSTANT character_L, 4C
000 CONSTANT character_M, 4D
000 CONSTANT character_N, 4E
000 CONSTANT character_O, 4F
000 CONSTANT character_P, 50
000 CONSTANT character_Q, 51
000 CONSTANT character_R, 52
000 CONSTANT character_S, 53
000 CONSTANT character_T, 54
000 CONSTANT character_U, 55
000 CONSTANT character_V, 56
000 CONSTANT character_W, 57
000 CONSTANT character_X, 58
000 CONSTANT character_Y, 59
000 CONSTANT character_Z, 5A
000 CONSTANT character_0, 30
000 CONSTANT character_1, 31
000 CONSTANT character_2, 32
000 CONSTANT character_3, 33
000 CONSTANT character_4, 34
000 CONSTANT character_5, 35
000 CONSTANT character_6, 36
000 CONSTANT character_7, 37
000 CONSTANT character_8, 38
000 CONSTANT character_9, 39
000 CONSTANT character_colon, 3A
000 CONSTANT character_stop, 2E
000 CONSTANT character_semi_colon, 3B
000 CONSTANT character_minus, 2D
000 CONSTANT character_divide, 2F;'/'
000 CONSTANT character_plus, 2B
000 CONSTANT character_comma, 2C
000 CONSTANT character_less_than, 3C
000 CONSTANT character_greater_than, 3E
000 CONSTANT character_equals, 3D
000 CONSTANT character_space, 20
000 CONSTANT character_CR, 0D;carriage return
000 CONSTANT character_question, 3F;'?'
000 CONSTANT character_dollar, 24
000 CONSTANT character_exclaim, 21;'!'
000 CONSTANT character_BS, 08;Back Space command character
000 ;
000 ;
000 ;
000 ;
000 ;
000 
;**************************************************************************************
000 ; Initialise the system
000 
;**************************************************************************************
000 ;
000 cold_start: LOAD s0, 00
001 STORE s0, SUM
002 STORE s0, SUM2
003 STORE s0, COUNT
004 OUTPUT s0, LED_port
005 ;
005 ENABLE INTERRUPT;enable interrupts
006 
;**************************************************************************************
006 ; Main program
006 
;**************************************************************************************
006 ;
006 ; Display welcome message for design
006 ;
006 main_program: CALL delay_1s
007 LOAD s0, 01
008 OUTPUT s0, LED_port
009 CALL delay_1s
00A LOAD s0, 00
00B OUTPUT s0, LED_port
00C JUMP main_program
00D 
;**************************************************************************************
00D ; Software delay routines
00D 
;**************************************************************************************
00D ;
00D ; Delay of 1us.
00D ;
00D 
; Constant value 'delay_1us_constant' reflects the clock applied to KCPSM3. Every
00D 
; instruction executes in 2 clock cycles making the calculation highly predictable.
00D 
; The '6' in the following equation allows for the 'CALL delay_1us' instruction used
00D ; in the initiating code. Interrupts may effect software derived delays.
00D ;
00D 
; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
00D ;
00D ; Registers used s0
00D ;
00D delay_1us: LOAD s0, delay_1us_constant
00E wait_1us: SUB s0, 01
00F JUMP NZ, wait_1us
010 RETURN
011 ;
011 ; Delay of 40us.
011 ;
011 ; Registers used s0, s1
011 ;
011 delay_40us: LOAD s1, 28;40 x 1us = 40us
012 wait_40us: CALL delay_1us
013 SUB s1, 01
014 JUMP NZ, wait_40us
015 RETURN
016 ;
016 ;
016 ; Delay of 1ms.
016 ;
016 ; Registers used s0, s1, s2
016 ;
016 delay_1ms: LOAD s2, 19;25 x 40us = 1ms
017 wait_1ms: CALL delay_40us
018 SUB s2, 01
019 JUMP NZ, wait_1ms
01A RETURN
01B ;
01B ; Delay of 20ms.
01B ;
01B ; Delay of 20ms used during initialisation.
01B ;
01B ; Registers used s0, s1, s2, s3
01B ;
01B delay_20ms: LOAD s3, 14;20 x 1ms = 20ms
01C wait_20ms: CALL delay_1ms
01D SUB s3, 01
01E JUMP NZ, wait_20ms
01F RETURN
020 delay_100ms: LOAD s3, 64;100 x 1ms = 20ms
021 wait_100ms: CALL delay_1ms
022 SUB s3, 01
023 JUMP NZ, wait_100ms
024 RETURN
025 delay_200ms: LOAD s3, C8;200 x 1ms = 20ms
026 wait_200ms: CALL delay_1ms
027 SUB s3, 01
028 JUMP NZ, wait_200ms
029 RETURN
02A ;
02A ; Delay of approximately 1 second.
02A ;
02A ; Registers used s0, s1, s2, s3, s4
02A ;
02A delay_1s: LOAD s4, 32;50 x 20ms = 1000ms
02B wait_1s: CALL delay_20ms
02C SUB s4, 01
02D JUMP NZ, wait_1s
02E RETURN
02F ;
02F ;
02F ;
02F 
;**************************************************************************************
02F ; Interrupt Service Routine (ISR)
02F 
;**************************************************************************************
02F ;
02F 
; The interrupt is used purely to provide a 1 second heart beat binary counter pattern
02F ; on the 8 LEDs.
02F ;
02F ISR: STORE s0, ISR_preserve_s0;preserve register
030 STORE s1, ISR_preserve_s1;preserve register
031 STORE s2, ISR_preserve_s2;preserve register
032 STORE s3, ISR_preserve_s3;preserve register
033 AND s0, s0;clear carry
034 XOR s0, s0;clear register, clear zero flag
035 AND s1, s1;clear carry
036 XOR s1, s1;clear register, clear zero flag
037 AND s2, s2;clear carry
038 XOR s2, s2;clear register, clear zero flag
039 AND s3, s3;clear carry
03A XOR s3, s3;clear register, clear zero flag
03B INPUT s0, DATA_IN_PORT;get new audio_data
03C FETCH s1, SUM;get SUM
03D FETCH s2, SUM2;get SUM2 (higher 8 bits)
03E FETCH s3, COUNT;get counter (0 to 256)
03F COMPARE s0, 80;check if audio_data[7] is 1
040 JUMP Z, twos_comp
041 JUMP NC, twos_comp
042 JUMP addition
043 twos_comp: XOR s0, FF;invert
044 ADD s0, 01;Add 1
045 addition: ADD s1, s0
046 ADDCY s2, 00
047 count256: COMPARE s3, FF
048 JUMP Z, display_leds
049 ADD s3, 01
04A JUMP returnn
04B display_leds: SL0 s2
04C SLA s1
04D SL0 s2
04E SLA s1
04F SL0 s2
050 SLA s1
051 SL0 s2
052 SLA s1
053 SL0 s2
054 SLA s1
055 SL0 s2
056 SLA s1
057 SL0 s2
058 SLA s1
059 SL0 s2
05A SLA s1;left shift 8 times (divide by 256)
05B msb8: COMPARE s1, 80;check if s1[7] is one or not
05C JUMP C, msb7
05D LOAD s1, FF
05E JUMP displayy
05F msb7: COMPARE s1, 40;check if s1[6] is one or not
060 JUMP C, msb6
061 LOAD s1, FE
062 JUMP displayy
063 msb6: COMPARE s1, 20;check if s1[5] is one or not
064 JUMP C, msb5
065 LOAD s1, FC
066 JUMP displayy
067 msb5: COMPARE s1, 10;check if s1[4] is one or not
068 JUMP C, msb4
069 LOAD s1, F8
06A JUMP displayy
06B msb4: COMPARE s1, 08;check if s1[3] is one or not
06C JUMP C, msb3
06D LOAD s1, F0
06E JUMP displayy
06F msb3: COMPARE s1, 04;check if s1[2] is one or not
070 JUMP C, msb2
071 LOAD s1, E0
072 JUMP displayy
073 msb2: COMPARE s1, 02;check if s1[1] is one or not
074 JUMP C, msb1
075 LOAD s1, C0
076 JUMP displayy
077 msb1: COMPARE s1, 01;check if s1[0] is one or not
078 JUMP C, msb0
079 LOAD s1, 80
07A JUMP displayy
07B msb0: LOAD s1, 00
07C displayy: OUTPUT s1, LED_ADDR_port;display counter value on LEDs
07D LOAD s1, 00
07E LOAD s2, 00
07F LOAD s3, 00;counter goes to zero
080 returnn: STORE s1, SUM;store sum
081 STORE s2, SUM2;store sum higher bits
082 STORE s3, COUNT;store counter
083 FETCH s0, ISR_preserve_s0;restore register
084 FETCH s1, ISR_preserve_s1;restore register
085 FETCH s2, ISR_preserve_s2;restore register
086 FETCH s3, ISR_preserve_s3;restore register
087 RETURNI ENABLE
088 ;
088 ;
088 
;**************************************************************************************
088 ; Interrupt Vector
088 
;**************************************************************************************
088 ;
3FF ADDRESS 3FF
3FF JUMP ISR
3FF ;
3FF ;

PASS 5 - Writing reformatted PSM file
           pracpico.fmt

PASS 6 - Writing assembler log file
           pracpico.log

PASS 7 - Writing coefficient file
           pracpico.coe

PASS 8 - Writing VHDL memory definition file
           pracpico.vhd

PASS 9 - Writing Verilog memory definition file
           pracpico.v

PASS 10 - Writing System Generator memory definition file
           pracpico.m

PASS 11 - Writing memory definition files
           pracpico.hex
           pracpico.dec
           pracpico.mem


KCPSM3 successful.

KCPSM3 complete.

